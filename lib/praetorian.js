/**
* @name /.js
* @description Validates all inputs against a required structure and returns any errors that it finds
* @since Fri Oct 04 12:20:21 BST 2013
* @author Kevin Hodges <kevin.hodges@holidayextras.com>
*/

(function() {
	// get some stuff we need to support Praetorian
	var _ = require( 'underscore' ), moment = require( 'moment' );
	var praetorian = function() {};

	// BITWISE...?
	var primitiveTypes = {
		ARRAY: 'array',
		BOOLEAN: 'boolean',
		OBJECT: 'object',
		STRING: 'string',
		INTEGER: 'integer',
		NULL: 'null'
	}

	// create a shorthand then export the Praetorian object for NodeJS
	exports = module.exports = praetorian;

	praetorian.prototype.validate = function( json, schema, callback ) {

		/*
		*	An array of objects that define all the errors generated by the schema against
		*/
		var errors = [];

		var messagInvalidTypeMustBeArray = 'Invalid type, expected Array';
		var messagInvalidTypeMustBeObject = 'Invalid type, expected Object';

		var addError = function( element, message ) {
			// console.log( 'addError', element, message );
			errors.push( { 'element': element, 'message': message } );
		}

		// little closure to manage rule adherence
		var rules = function( data ) {
			// state for lifetime of the rules call (rules are chainable)
			var check = {
				data: data == null || ( isNaN( data ) && data.length == undefined ) ? '' : data,
				error: null
			}

			return {
				isInteger: function() {
					console.log( 'isInteger() on ', check.data );
					if( !_.isNumber( check.data ) ) {
						check.error = 'Not a number';
					}
					return this;
				},
				isString: function() {
					console.log( 'isString() on ', check.data );
					if( !_.isString( check.data ) ) {
						check.error = 'Not a string';
					}
					return this;
				},
				isDate: function() {
					console.log( 'isDate() on ', check.data );
					// few checks on the date here:
					// 1. has the user passed in too many or too few days for the selected month/year combination (factors in leap years)
					// 2. is the month too high or low (>12 or <1)
					// 3. date must be YYYY-MM-DD formate
					if( _.isString( check.data ) ) { 
						var date = check.data.split( '-' );
						// must have 3 parts
						if( date.length === 3 ) {
							var selectedYear = date[0];
							// parseInt incase we have preceeding zeros (we don't want em)
							var selectedMonth = parseInt( date[1] );
							var selectedDay = parseInt( date[2] );
							// how long is the selected month?
							var daysInMonth = new Date( selectedYear, selectedMonth, 0 ).getDate();

							// have we got too many days?
							if( selectedDay > daysInMonth ) {
								check.error = 'Too many days for month';
							}
							// have we got too few days?
							if( selectedDay < 1 ) {
								check.error ='Too few days for month';
							}

							// check months is not greater than 12...
							if( selectedMonth > 12 ) {
								check.error = 'Month value too high';
							}
							// and not less than 1...
							if( selectedMonth < 1 ) {
								check.error = 'Month value too low';
							}
						} else {
							// split on hyphen failed to produce 3 parts
							check.error = 'Invalid date format';
						}
					} else {
						// not a string :/
						check.error = 'Invalid date format';
					}

					return this;
				},
				lengthBetween: function( min, max ) {
					console.log( 'lengthBetween() on ', check.data );
					if ( check.data.length < min ) {
						check.error = 'Value is too short';
					}
					if ( max !== undefined && check.data.length > max ) {
						check.error = 'Value is too long';
					}
					return this;
				},
				execute: function( callback ) {
					callback( check.error );
				}
			};
		}

		// check all the fields that are "required" by the schema are present
		// if we hit a complex type (object, array), only recurse if data is passed for a sub-schema
		var requiredJson = function( json, schema, elementPrefix ){

			// console.log( 'schema', schema );
			// check json also matches the schema requirements
			_.each( schema, function( levelValue, levelKey ) {

				// is this field "required" (explicit true, don't want people passing no 1 or "true" shit)
				if( ( levelValue.required === true ) && ( _.isUndefined( json[levelKey] ) ) ) {
					// BOOO!, #fail
					addError( elementPrefix + levelKey, 'Required but not found' );
				} else {
					// "required" is false or undefined, ignore and continue
				}

				// if the json actually has a value...
				if( !_.isUndefined( json[levelKey] ) ) {
					// schema says type ARRAY and we have "items" or OBJECT and we have "properties" we continue
					if( ( !_.isUndefined( levelValue.items ) ) && ( levelValue.type === primitiveTypes.ARRAY ) && _.isArray( json[levelKey] ) ) {
						_.each( json[levelKey], function( jsonValue, jsonKey ) {
							requiredJson( jsonValue, levelValue.items, elementPrefix + levelKey + '[' + jsonKey + '].' );
						} );
					} else if( ( !_.isUndefined( levelValue.properties ) ) && ( levelValue.type === primitiveTypes.OBJECT ) && _.isObject( json[levelKey] ) ) {
						requiredJson( json[levelKey], levelValue.properties, elementPrefix + levelKey + '.' );
					}					
				}

			} );

		}

		var parseJson = function( json, schema, schemaType, elementPrefix ) {

			// console.log('-=-=-=-=-=-=-');
			// console.log( 'received schemaType', schemaType );
			// console.log( 'received JSON', json );
			// console.log( 'received schema', schema );
			
			// for this level, loop over all the json and see if its required by the schema
			_.each( json, function( levelValue, levelKey ) {

				// console.log( 'levelKey', levelKey );
				// console.log( 'levelValue', levelValue );

				// is it a node in the schema?
				if( _.isUndefined( schema[levelKey] ) ) {
					// it's not, can it
					delete json[levelKey];
				} else {
					if( schema[levelKey].type === primitiveTypes.ARRAY ) {
						/* Array */
						// check its ACTUALLY an array
						if( _.isArray( json[levelKey] ) ) {
							// loop each element in the array and parse those as individual objects against their schema
							_.each( json[levelKey], function( arrayElement, loopCount ) {
								parseJson( arrayElement, schema[levelKey].items, schema[levelKey].type, levelKey + '[' + loopCount + '].' );
							} );
						} else {
							// ERROR: this value should be an ARRAY but it's not (object of some other description?)
							addError( elementPrefix + levelKey, messagInvalidTypeMustBeArray );
						}
					} else if( schema[levelKey].type === primitiveTypes.OBJECT ) {
						/* Object */
						// must be an object (not null or undefined or anything silly)
						if( _.isObject( json[levelKey] ) && !_.isArray( json[levelKey] ) && !_.isNull( json[levelKey] ) && !_.isUndefined( json[levelKey] ) ) {
							parseJson( json[levelKey], schema[levelKey].properties, schema[levelKey].type, levelKey + '.' );
						} else {
							// ERROR: this value should be an OBJECT but its an array
							addError( elementPrefix + levelKey, messagInvalidTypeMustBeObject );
						}
					} else if( ( !_.isUndefined( schema[levelKey].validation ) ) && ( !_.isUndefined( schema[levelKey].validation.rules ) ) ) {

						// Handle anything else which has rules here (primitives? string, number...)
						_.each( schema[levelKey].validation.rules, function( rule, ruleKey ) {

							var validator = new rules( json[levelKey] );
							switch( ruleKey )  {

								case 'type':
									// basic type checking
									switch( rule ) {
										case 'string':
											validator.isString();
											break;

										case 'integer':
											validator.isInteger();
											break;

										case 'date':
											validator.isDate();
											break;
									}
									break;

								case 'lengthBetween': // max and min (inclusive)
									validator.lengthBetween( rule.min, rule.max );
									break;

								default:
									// case not handled 
									break;

							}

							// execute the validation routines and push any errors onto the Praetorian stack
							validator.execute( function( err ) {
								if( err ){
									addError( elementPrefix + levelKey, err );
								}
							} );
						} );
						
					} else {
						// no validation found, whatevs...
						console.log( 'no validation rules found for ' + elementPrefix + levelKey );
					}
					
				}

			} );

		}

		try {

			// ensure json and schema are both objects
			if( !_.isObject( json ) ) {
				throw new TypeError( 'parameter "json" is not [object]' );
			} 
			if( !_.isObject( schema ) ) {
				throw new TypeError( 'parameter "schema" is not [object]' );
			}
			if( !_.isFunction( callback ) ) {
				throw new TypeError( 'parameter "callback" is not [function]' );
			}

			// -1. Do we treat the whole thing as a stack? Or reusable "function"
			// 0. benchmark against Doorman for validating a data set against a structure
			// # 1. remove all junk data (recursive) keys that dont exist in the structure
			// 2. ensure items that are present (if REQUIRED) and are of the correct type
			// 3. check for ITEMS
			// 4. check for STRUCTURES
			// 5. what happens when we find an OBJECT? i.e. roomInfo on POST book
			// 6. deal with error handling (pass back up stack, modified data)
			// 7. individual validation routines
			// 8. config for Praetorian, build Doorman config in to somewhere but can be overridable :/
			// 9. isValidDate, isNumber etc, can we use Underscore (isFinite)?
			// 10. Identical objects are equal. `0 === -0`, but they aren't identical.
			// 11. better error messageing structure (consolidated)
			// 12. requirements() for outputting errors from a stack
			// 13. figure out what sort of return structures we will provide
			// 14. what is the difference between ARRAY and ITEMS
			// 15. list types, OBJECT ARRAY, STRUCTURE, ITEMS, CHECKSUM
			// #16. in Revolver, book roomInfo is ARRAY but is passed as [object]...
			
			// console.log( 'before', json );
			parseJson( json, schema, undefined, '' );
			// console.log( 'after', json );

			requiredJson( json, schema, '' );

			if( errors.length > 0 ) {
				// send the errors back
				callback( errors );
			} else {
				// send the decent json back
				callback( null, json );	
			}
		} catch ( err ) {

			// somehow, return the err in the error callback
			if( callback ) {
				callback( err );
			} else {
				return err;
			}

		}

	};

	praetorian.prototype.requirements = function( schema, callback ) {

		try {

			var results = [];
    	if( schema == null ) return results;

			function addRequirement( message, field ) {
				// returns the field "requirement" details in a consistent schema
				return {
					'example': message,
					'description': field['description'],
					'required': ( field['required'] ) ? true : false
				};
			}

			if( !_.isObject( schema ) ) {
				throw new TypeError( 'parameter "schema" is not [object]' );
			}
			if( !_.isFunction( callback ) ) {
				throw new TypeError( 'parameter "callback" is not [function]' );
			}

			_.each( schema, function( field, fieldKey ) {
				// add some details to the requirements
				results[fieldKey] = addRequirement( ( field.validation && field.validation.example ) ? field.validation.example : 'No example given', field );
			} );

			callback( null, results );

		} catch ( err ) {
			// somehow, return the err in the error callback
			if( callback ) {
				callback( err );
			} else {
				return err;
			}
		}

	};

})();