/**
* @name /lib/praetorian.js
* @description Validates all inputs against a required structure and returns any errors that it finds
* @since Fri Oct 04 12:20:21 BST 2013
* @author Kevin Hodges <kevin.hodges@holidayextras.com>
*/

(function() {
	// get some stuff we need to support Praetorian
	var _ = require( 'lodash' ), moment = require( 'moment' );
	var praetorian = function( options, customRules ) {

		// default options
		this.options = {
			automaticTypeConversion: true,
			language: 'en'
		}

		// if there's any overriding options, blat them over the defaults
		this.options = _.extend( this.options, options );

		this.customRules = customRules;

		// default language EN
		this.options.messages = require( './internationalisation/en' ); // ISO 639‑1
		
		if ( ( this.options.language != '' ) && ( this.options.language.toLowerCase() != 'en' ) ) {
			// now fetch the language settings based on the requested language
			var internationalLanguage = require( './internationalisation/' + this.options.language.toLowerCase() ); // ISO 639‑1
			if ( internationalLanguage ) {
				this.options.messages = _.extend( this.options.messages, internationalLanguage );
			}
		}
	};

	// types we accept
	var primitiveTypes = {
		ARRAY: 'array',
		BOOLEAN: 'boolean',
		DECIMAL: 'decimal',
		INTEGER: 'integer',
		OBJECT: 'object',
		STRING: 'string',
		DATE: 'date' // ISO 8601, naturally
	}

	// create a shorthand then export the Praetorian object for Nodejs
	exports = module.exports = praetorian;

	praetorian.prototype.validate = function( json, schema, callback ) {

		// grab the options from the protoype and make them available inside this function
		var options = this.options;

		var customRules = this.customRules;

		/*
		*	An array of objects that define all the errors generated by the json against the schema
		*/
		var errors = [];

		var addError = function( element, message ) {
			errors.push( { 'element': element, 'message': message } );
		}

		// little closure to manage rule adherence
		var rules = function( data ) {
			// state for lifetime of the rules call (rules are chainable)
			var check = {
				data: data == null || ( isNaN( data ) && data.length == undefined ) ? '' : data,
				error: null
			}

			return {
				boolean: function() {
					// must be one of these bad boys
					if( _.indexOf( [true, false, "true", "false"], check.data ) === -1  ) {
						check.error = options.messages.VALUE_NOT_A_BOOLEAN;
					}
					return this;
				},
				date: function() {
					console.log('date check');
					// few checks on the date here:
					// 1. has the user passed in too many or too few days for the selected month/year combination (factors in leap years)
					// 2. is the month too high or low (>12 or <1)
					// 3. date must be YYYY-MM-DD format
					if( _.isString( check.data ) ) { 
						var date = check.data.split( '-' );
						// must have 3 parts
						if( date.length === 3 ) {
							var selectedYear = date[0];
							// parseInt incase we have preceeding zeros (we don't want em)
							var selectedMonth = parseInt( date[1] );
							var selectedDay = parseInt( date[2] );
							// how long is the selected month?
							var daysInMonth = new Date( selectedYear, selectedMonth, 0 ).getDate();

							// have we got too many days?
							if( selectedDay > daysInMonth ) {
								check.error = options.messages.VALUE_FOR_MONTH_HAS_TOO_MANY_DAYS;
							} else if( selectedDay < 1 ) {
								// have we got too few days?
								check.error = options.messages.VALUE_FOR_MONTH_HAS_TOO_FEW_DAYS;
							}

							// check months is not greater than 12...
							if( selectedMonth > 12 ) {
								check.error = options.messages.VALUE_FOR_MONTH_TOO_HIGH;
							} else if( selectedMonth < 1 ) {
								// and not less than 1...
								check.error = options.messages.VALUE_FOR_MONTH_TOO_LOW;
							}
						} else {
							// split on hyphen failed to produce 3 parts
							check.error = options.messages.VALUE_FOR_MONTH_INVALID_FORMAT;
						}
					} else {
						// not a string :/
						check.error = options.messages.VALUE_FOR_MONTH_INVALID_FORMAT;
					}

					return this;
				},
				decimal: function() {
					// cant assume automaticTypeConversion is on so isNumber will hopefully cover the check here
					if( _.isNaN( parseFloat( check.data ) ) ) {
						check.error = options.messages.VALUE_NOT_A_DECIMAL;
					}
					return this;
				},
				integer: function() {
					if( _.isNaN( parseInt( check.data ) ) ) {
						check.error = options.messages.VALUE_NOT_A_INTEGER;
					}
					return this;
				},
				string: function() {
					console.log('string check');
					if( !_.isString( check.data ) ) {
						check.error = options.messages.VALUE_NOT_A_STRING;
					}
					return this;
				},
				maxLength: function( maxLength ) {
					console.log( 'maxLength check', maxLength );
					if( check.data.length > maxLength ) {
						check.error = options.messages.VALUE_TOO_LONG + ' ' + maxLength + ' ' + options.messages.VALUE_CHARACTERS;
					}
					return this;
				},
				minLength: function( minLength ) {
					console.log( 'minLength check', minLength );
					if( check.data.length < minLength ) {
						check.error = options.messages.VALUE_TOO_SHORT + ' ' + minLength + ' ' + options.messages.VALUE_CHARACTERS;
					}
					return this;
				},
				enum: function( permittedValuesArray ) {
					console.log( 'enum check', permittedValuesArray );
					if( _.indexOf( permittedValuesArray, check.data ) === -1 ) {
						check.error = options.messages.VALUE_NOT_IN_ARRAY;
					}
					return this;
				},
				execute: function( callback ) {
					callback( check.error );
				}
			};
		}

		// if the schema says the value should be boolean, integer or decimal, make sure it is
		var forceType = function( schema, value ) {
			// by default, always pass back what came in so if we can't match it, stuff doesn't go missing
			var result = value;
			switch( schema.type ) {
				case 'boolean':
					// true booleans can stay as they are, if we match string bools, boolean them up bitches
					result = ( value === 'true' || value === 'false' ) ? !!value: value;
					break;
				case 'integer':
					result = !_.isNaN( parseInt( value ) ) ? parseInt( value ): value;
					break;
				case 'decimal':
					result = !_.isNaN( parseFloat( value ) ) ? parseFloat( value ): value;
					break;
				default:
					break;
			}

			return result;
		}

		// check all the fields that are "required" by the schema are present
		// if we hit a complex type (object, array), only recurse if data is passed for a sub-schema
		var requiredJson = function( json, schema, elementPrefix ){

			// check json also matches the schema requirements
			_.each( schema, function( levelValue, levelKey ) {

				// is this field "required" (explicit true, don't want people passing no 1 or "true" shit)
				if( ( levelValue.required === true ) && ( _.isUndefined( json[levelKey] ) ) ) {
					// BOOO!, #fail
					addError( elementPrefix + levelKey, options.messages.FIELD_REQUIRED_BUT_NOT_FOUND );
				} else {
					// "required" is false or undefined, ignore and continue
				}

				// if the json actually has a value...
				if( json[levelKey] ) {
					// schema says type ARRAY and we have "items" or OBJECT and we have "properties" we continue
					if( ( !_.isUndefined( levelValue.items ) ) && ( levelValue.type === primitiveTypes.ARRAY ) && _.isArray( json[levelKey] ) ) {
						_.each( json[levelKey], function( jsonValue, jsonKey ) {
							if( !_.isUndefined( jsonValue ) ) {
								requiredJson( jsonValue, levelValue.items, elementPrefix + levelKey + '[' + jsonKey + '].' );
							} else {
								// in this instance, an element in the array was not passed at all , no harm done
								// i.e. no name[0].initial was passed but name[1].initial was
							}
						} );
					} else if( ( !_.isUndefined( levelValue.properties ) ) && ( levelValue.type === primitiveTypes.OBJECT ) && _.isObject( json[levelKey] ) ) {
						requiredJson( json[levelKey], levelValue.properties, elementPrefix + levelKey + '.' );
					}					
				}

			} );

		}

		var parseJson = function( json, schema, elementPrefix ) {

			// for this level, loop over all the json and see if its required by the schema
			_.each( json, function( levelValue, levelKey ) {
				// is it a node in the schema?
				if( !schema[levelKey] ) {
					// it's not, can it
					delete json[levelKey];
				} else {

					// only convert types if the consumer is cool with that
					if( options.automaticTypeConversion ) {
						// type conversion for primitive types that might get passed as a string
						json[levelKey] = forceType( schema[levelKey], levelValue );
					}

					// start doing stuff
					if( schema[levelKey].type === primitiveTypes.ARRAY ) {
						/* Array */
						// check its ACTUALLY an array
						if( _.isArray( json[levelKey] ) ) {
							// loop each element in the array and parse those as individual objects against their schema
							_.each( json[levelKey], function( arrayElement, loopCount ) {
								if( !_.isUndefined( arrayElement ) ) {
									parseJson( arrayElement, schema[levelKey].items, levelKey + '[' + loopCount + '].' );
								} else {
									// in this instance, an element in the array was not passed at all , no harm done
									// i.e. name[0].initial was not passed but name[1].initial was
								}
							} );
						} else {
							// ERROR: this value should be an ARRAY but it's not (object of some other description?)
							addError( elementPrefix + levelKey, options.messages.VALUE_TYPE_MUST_BE_ARRAY );
						}
					} else if( schema[levelKey].type === primitiveTypes.OBJECT ) {
						/* Object */
						// must be an object (not null or undefined or anything silly)
						if( _.isObject( json[levelKey] ) && !_.isArray( json[levelKey] ) && !_.isNull( json[levelKey] ) && !_.isUndefined( json[levelKey] ) ) {
							parseJson( json[levelKey], schema[levelKey].properties, levelKey + '.' );
						} else {
							// ERROR: this value should be an OBJECT but its an array
							addError( elementPrefix + levelKey, options.messages.VALUE_TYPE_MUST_BE_OBJECT );
						}
					} else if( schema[levelKey].type ) {

						// basic "type" validation only non complex primitive types, 
						// objects and arrays are dealt with by recursing into them
						var validator = new rules( json[levelKey] );
						validator[schema[levelKey].type]();

						if( customRules[schema[levelKey].validation] ) {
							// loop the rules and queue some ancilliary calls
							_.each( customRules[schema[levelKey].validation].rules, function( ruleValue, ruleName ) {
								validator[ruleName]( ruleValue );	
							} );
						}
						
						// execute the validation routines and push any errors onto the Praetorian stack
						validator.execute( function( err ) {
							if( err ){
								addError( elementPrefix + levelKey, err );
							}
						} );
						
					} else {
						// no validation found, whatevs...
					}
					
				}

			} );

		}

		try {

			// ensure json and schema are both objects
			if( !_.isObject( json ) ) {
				throw new TypeError( options.messages.PARAMETER_JSON_NOT_OBJECT );
			} 
			if( !_.isObject( schema ) ) {
				throw new TypeError( options.messages.PARAMETER_SCHEMA_NOT_OBJECT );
			}
			if( !_.isFunction( callback ) ) {
				throw new TypeError( options.messages.PARAMETER_CALLBACK_NOT_FUNCTION );
			}

			// TODO:
			// 1. rules passed in on construction but don't sit inside Praetorian module, basic types should be basked in + date
			// #2. internationalisation, abstract errors to a lib GB and default settings go to GB
			// 3. checksum type

			parseJson( json, schema, '' );

			requiredJson( json, schema, '' );

			if( errors.length > 0 ) {
				// send the errors back
				callback( errors );
			} else {
				// send the decent json back
				callback( null, json );	
			}
		} catch ( err ) {

			// somehow, return the err in the error callback
			if( callback ) {
				callback( err );
			} else {
				return err;
			}

		}

	};

	praetorian.prototype.requirements = function( schema, callback ) {

		try {

			// grab the options from the protoype and make them available inside this function
			var options = this.options;
			var customRules = this.customRules;

			var addRequirement = function( field ) {
				var requirementExample = options.messages.EXAMPLE_NOT_GIVEN;
				// returns the field "requirement" details in a consistent schema
				if( ( field.validation ) && ( customRules[field.validation].example ) ) {
					requirementExample = customRules[field.validation].example;
				} else if( ( field.type ) && ( options.messages['EXAMPLE_MUST_BE_' + field.type.toUpperCase()] ) ) {
					requirementExample = options.messages['EXAMPLE_MUST_BE_' + field.type.toUpperCase()];
				}
				return {
					'example': requirementExample,
					'required': ( field['required'] ) ? true : false
				};
			}

			var getRequirements = function( schema, requirements ) {

				var results = {};

				_.each( schema, function( schemaValue, schemaKey ) {
					if( schemaValue.type === primitiveTypes.OBJECT || schemaValue.type === primitiveTypes.ARRAY ) {
						// sub schema depending on the parent type, get the results for it
						var subSchemaResults = {};
						if( schemaValue.properties ) {
							subSchemaResults['properties'] = getRequirements( schemaValue.properties );
						} else {
							subSchemaResults['items'] = getRequirements( schemaValue.items );
						}
						// bind it with the requirements at this level and continue
						results[schemaKey] = _.extend( addRequirement( schemaValue ), subSchemaResults ) ;

					} else {
						// add some details to the results for the schema
						results[schemaKey] = addRequirement( schemaValue );
					}
				} );

				return results;

			}

			if( !_.isObject( schema ) ) {
				throw new TypeError( options.messages.PARAMETER_SCHEMA_NOT_OBJECT );
			}
			if( !_.isFunction( callback ) ) {
				throw new TypeError( options.messages.PARAMETER_CALLBACK_NOT_FUNCTION );
			}

			// send the results back a-la-node
			callback( null, getRequirements( schema ) );

		} catch ( err ) {
			// somehow, return the err in the error callback
			if( callback ) {
				callback( err );
			} else {
				return err;
			}
		}

	};

})();