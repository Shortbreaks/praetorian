/**
* @name /lib/praetorian.js
* @description Validates all inputs against a required structure and returns any errors that it finds
* @since Fri Oct 04 12:20:21 BST 2013
* @author Kevin Hodges <kevin.hodges@holidayextras.com>
*/

(function() {

	// get some stuff we need to support Praetorian
	var _ = require( 'lodash' ), crypto = require( 'crypto' );

	var praetorian = function( myOptions, myTasks ) {

		var self = this;
		// default options
		self.options = {
			automaticTypeConversion: true,
			language: 'en',
			salt: 'praetorian'
		}

		// if there's any overriding options, blat them over the defaults
		self.options = _.extend( self.options, myOptions );

		// now fetch the language settings based on the requested language
		self.options.messages = require( './internationalisation/' + self.options.language ); // ISO 639â€‘1

		// tasks are your custom validation routines, make them available to the instance
		self.tasks = myTasks;

	};

	// types we accept
	var primitiveTypes = {
		ARRAY: 'array',
		BOOLEAN: 'boolean',
		DATE: 'date', // ISO 8601, naturally
		DECIMAL: 'decimal',
		HASH: 'hash',
		INTEGER: 'integer',
		OBJECT: 'object',
		STRING: 'string'
	}
	var complexTypes = {
		ITEMS: 'items'
	}

	// create a shorthand then export the Praetorian object for Nodejs
	exports = module.exports = praetorian;

	// publically accessible hash generator
	praetorian.prototype.generateHash = function( data ) {
		return crypto.createHmac( 'sha1', this.options.salt ).update( JSON.stringify( data ) ).digest( 'hex' );
	}

	praetorian.prototype.validate = function( json, schema, callback ) {

		var self = this;

		/*
		*	An array of objects that define all the errors generated by the json against the schema
		*/
		var errors = [];

		var addError = function( element, message ) {
			errors.push( { 'element': element, 'message': message } );
		}

		// little closure to manage rule adherence
		var rules = function( data ) {

			// state for lifetime of the rules call (rules are chainable)
			var check = {
				data: data == null || ( ( isNaN( data ) && data.length == undefined ) && !_.isObject( data ) ) ? '' : data,
				error: null
			}

			return {
				boolean: function() {
					// must be one of these bad boys
					if( _.indexOf( [true, false, 'true', 'false'], check.data ) === -1  ) {
						check.error = self.options.messages.VALUE_NOT_A_BOOLEAN;
					}
					return this;
				},
				date: function() {
					// 1. has the user passed in too many or too few days for the selected month/year combination (factors in leap years)
					// 2. is the month too high or low (>12 or <1)
					// 3. date must be YYYY-MM-DD format
					if( _.isString( check.data ) ) {
						var date = check.data.split( '-' );
						// must have 3 parts
						if( date.length === 3 ) {
							var selectedYear = date[0];
							// parseInt incase we have preceeding zeros (we don't want em)
							var selectedMonth = parseInt( date[1] );
							var selectedDay = parseInt( date[2] );
							//check if data is a vailid date
							if( new Date( selectedYear, selectedMonth, selectedDay ) == 'Invalid Date' ) {
								check.error = self.options.messages.VALUE_FOR_DATE_INVALID_FORMAT;
							}
							// how long is the selected month?
							var daysInMonth = new Date( selectedYear, selectedMonth, 0 ).getDate();

							// have we got too many days?
							if( selectedDay > daysInMonth ) {
								check.error = self.options.messages.VALUE_FOR_MONTH_HAS_TOO_MANY_DAYS;
							} else if( selectedDay < 1 ) {
								// have we got too few days?
								check.error = self.options.messages.VALUE_FOR_MONTH_HAS_TOO_FEW_DAYS;
							}

							// check months is not greater than 12...
							if( selectedMonth > 12 ) {
								check.error = self.options.messages.VALUE_FOR_MONTH_TOO_HIGH;
							} else if( selectedMonth < 1 ) {
								// and not less than 1...
								check.error = self.options.messages.VALUE_FOR_MONTH_TOO_LOW;
							}
						} else {
							// split on hyphen failed to produce 3 parts
							check.error = self.options.messages.VALUE_FOR_DATE_INVALID_FORMAT;
						}
					} else {
						// not a string :/
						check.error = self.options.messages.VALUE_FOR_DATE_INVALID_FORMAT;
					}

					return this;
				},
				decimal: function() {
					// cant assume automaticTypeConversion is on so isNumber will hopefully cover the check here
					if( _.isNaN( parseFloat( check.data ) ) ) {
						check.error = self.options.messages.VALUE_NOT_A_DECIMAL;
					}
					return this;
				},
				hash: function() {
					if( _.isUndefined( check.data.hash ) || ( !_.isString( check.data.hash ) ) ) {
						// invalid or not present "hash"
						check.error = self.options.messages.HASH_INVALID;
					} else if( !_.isObject( check.data.value ) ) {
						// "value" not present or not an object
						check.error = self.options.messages.HASH_VALUE_NOT_A_OBJECT;
					} else {
						// check the hash "checks out"
						if( self.generateHash( check.data.value ) !== check.data.hash ) {
							check.error = self.options.messages.HASH_INVALID;
						}
					}
					return this;
				},
				integer: function() {
					if( _.isNaN( parseInt( check.data ) ) ) {
						check.error = self.options.messages.VALUE_NOT_A_INTEGER;
					}
					return this;
				},
				string: function() {
					if( !_.isString( check.data ) ) {
						check.error = self.options.messages.VALUE_NOT_A_STRING;
					}
					return this;
				},
				maxLength: function( maxLength ) {
					if( check.data.length > maxLength ) {
						check.error = self.options.messages.VALUE_TOO_LONG + ' ' + maxLength + ' ' + self.options.messages.VALUE_CHARACTERS;
					}
					return this;
				},
				minLength: function( minLength ) {
					if( check.data.length < minLength ) {
						check.error = self.options.messages.VALUE_TOO_SHORT + ' ' + minLength + ' ' + self.options.messages.VALUE_CHARACTERS;
					}
					return this;
				},
				enum: function( permittedValuesArray ) {
					if( _.indexOf( permittedValuesArray, check.data ) === -1 ) {
						check.error = self.options.messages.VALUE_NOT_IN_ARRAY;
					}
					return this;
				},
				execute: function( callback ) {
					callback( check.error );
				}
			};
		}

		// if the schema says the value should be boolean, integer or decimal, make sure it is
		var forceType = function( schema, value ) {
			// by default, always pass back what came in so if we can't match it, stuff doesn't go missing
			var result = value;
			switch( schema.type ) {
				case 'boolean':
					// true booleans can stay as they are, if we match string bools, boolean them up bitches
					if ( value === 'true' ) {
						result = true;
					} else if ( value === 'false' ) {
						result = false;
					}
					break;
				case 'integer':
					result = !_.isNaN( parseInt( value ) ) ? parseInt( value ): value;
					break;
				case 'decimal':
					result = !_.isNaN( parseFloat( value ) ) ? parseFloat( value ): value;
					break;
				default:
					break;
			}

			return result;
		}
		/**
		* handleComplexData deals with the complex data type "ITEMS"
		* which is very specific to data type validated on the checksum passed in
		*/
		var handleComplexData = function ( json, schema ) {
			/* sample data structure handled in this function
			json = [
				{
					price: '74.30',
					data: {
						hotel: {
							arrivalDate: '2014-10-28',
							nights: 2,
							ITEMS: { //nested Items(supplement)
								price: '38.20',
								currency: 'GBP',
								data: { supplement: [Object] }
							}
						},
						ticket: [Object]
						},
					checksum: '3b47d34ee00ef9e4bb3aaa746fc487b95b7bb2d6'
				}
			]
			*/
			//loop through the "ITEMS" json
			_.each( json, function( item, key ) {
				//loop through data of each ITEM
				_.each( item.data, function( itemElement, itemKey ) {
					//if there is a schema linked with this item validate
					if( _.has( schema, itemKey ) ) {
						//validate any other schema (other than checksum) specified for this item
						var checkElement = _.cloneDeep( item );
						var elementPrefix = itemKey + ' ';
						parseJson( checkElement, schema[itemKey], elementPrefix );
						requiredJson( checkElement, schema[itemKey], elementPrefix );
					}
					//if data has more IIEMS deal with  them
					if( !_.isUndefined( itemElement.ITEMS ) ) {
						handleComplexData( itemElement.ITEMS, schema );
						//delete the nested ITEMS so we can continue validating the outer ITEMS
						//as the outer checksum calculation would not have included the nested ITEM
						delete itemElement.ITEMS;
						//loop through the items and validate that the hash matches the generated has for the item
					} else {
						if( _.isUndefined( item.checksum ) || item.checksum == '' ) {
							addError( 'ITEMS', self.options.messages.HASH_INVALID )
						} else {
							// copy the object
							var itemCopy = _.cloneDeep( item );
							// get a copy of the checksum
							var oldHash = itemCopy.checksum;
							// now remove it (it doesnt form part of the actual hash )
							delete itemCopy.checksum;
							var newHash = self.generateHash( itemCopy.data );
							// compare the hashes
							if( oldHash !== newHash ) {
								addError( 'ITEMS', self.options.messages.HASH_INVALID );
							}
						}
					}
				} );
			} );
		}

		// check all the fields that are "required" by the schema are present
		// if we hit a complex type (object, array), only recurse if data is passed for a sub-schema
		var requiredJson = function( json, schema, elementPrefix ) {
			// check json also matches the schema requirements
			_.each( schema, function( levelValue, levelKey ) {

				// is this field "required" (explicit true, don't want people passing no 1 or "true" shit)
				if( ( levelValue.required === true ) && ( _.isUndefined( json[levelKey] ) ) ) {
					// BOOO!, #fail
					addError( elementPrefix + levelKey, self.options.messages.FIELD_REQUIRED_BUT_NOT_FOUND );
				} else {
					// "required" is false or undefined, ignore and continue
				}

				// if the json actually has a value...
				if( json[levelKey] ) {

					// We need to ensure that "type" is always passed in.
					if( !levelValue.type ) {
						addError( elementPrefix + levelKey, self.options.messages.TYPE_REQUIRED_BUT_NOT_FOUND );
					} else if( ( !_.isUndefined( levelValue.items ) ) && ( levelValue.type === primitiveTypes.ARRAY ) && _.isArray( json[levelKey] ) ) {
						// schema says type ARRAY and we have "items" or OBJECT and we have "properties" we continue
						_.each( json[levelKey], function( jsonValue, jsonKey ) {
							if( !_.isUndefined( jsonValue ) ) {
								requiredJson( jsonValue, levelValue.items, elementPrefix + levelKey + '[' + jsonKey + '].' );
							} else {
								// in this instance, an element in the array was not passed at all , no harm done
								// i.e. no name[0].initial was passed but name[1].initial was
							}
						} );
					} else if( ( !_.isUndefined( levelValue.properties ) ) && ( levelValue.type === primitiveTypes.OBJECT ) && _.isObject( json[levelKey] ) ) {
						requiredJson( json[levelKey], levelValue.properties, elementPrefix + levelKey + '.' );
					} else if( levelValue.type == complexTypes.ITEMS ) {
						//pass in the json for items and any schema for nested items( levelValue[properties] )
						handleComplexData( _.cloneDeep( json[levelKey] ), levelValue.properties );
					}
				}

			} );

		}

		var parseJson = function( json, schema, elementPrefix ) {
			// for this level, loop over all the json and see if its required by the schema
			_.each( json, function( levelValue, levelKey ) {
				// is it a node in the schema?
				if( !schema[levelKey] ) {
					// it's not, can it
					delete json[levelKey];
				} else {
					// only convert types if the consumer is cool with that
					if( self.options.automaticTypeConversion ) {
						// type conversion for primitive types that might get passed as a string
						json[levelKey] = forceType( schema[levelKey], levelValue );
					}

					// start doing stuff
					if( schema[levelKey].type === primitiveTypes.ARRAY ) {
						/* Array */
						// check its ACTUALLY an array
						if( _.isArray( json[levelKey] ) ) {
							// Does the schema say there should be items?
							if( schema[levelKey].items ) {
								// loop each element in the array and parse those as individual objects against their schema
								_.each( json[levelKey], function( arrayElement, loopCount ) {
									if( !_.isUndefined( arrayElement ) ) {
										parseJson( arrayElement, schema[levelKey].items, levelKey + '[' + loopCount + '].' );
									} else {
										// in this instance, an element in the array was not passed at all , no harm done
										// i.e. name[0].initial was not passed but name[1].initial was
									}
								} );
							} else {
								// Schema says no "items" and as the value is an array, happy with that
							}
						} else {
							// ERROR: this value should be an ARRAY but it's not (object of some other description?)
							addError( elementPrefix + levelKey, self.options.messages.VALUE_TYPE_MUST_BE_ARRAY );
						}
					} else if( schema[levelKey].type === primitiveTypes.OBJECT ) {
						/* Object */
						// must be an object (not null or undefined or anything silly)
						if( _.isObject( json[levelKey] ) && !_.isArray( json[levelKey] ) && !_.isNull( json[levelKey] ) && !_.isUndefined( json[levelKey] ) ) {
							parseJson( json[levelKey], schema[levelKey].properties, levelKey + '.' );
						} else {
							// ERROR: this value should be an OBJECT but its an array
							addError( elementPrefix + levelKey, self.options.messages.VALUE_TYPE_MUST_BE_OBJECT );
						}
					} else if( schema[levelKey].type && schema[levelKey].type !== complexTypes.ITEMS ) {
						// basic "type" validation only non complex primitive types,
						// objects and arrays are dealt with by recursing into them
						var validator = new rules( json[levelKey] );
						validator[schema[levelKey].type]();

						if( schema[levelKey].validation ) {
							if( self.tasks && self.tasks[schema[levelKey].validation] ) {
								// get the task to be executed
								var task = self.tasks[schema[levelKey].validation];
								if( _.isFunction( task ) ) {
									// if its a function, overwrite the task function with the result of that function
									task = task.apply( null, schema[levelKey].arguments || null );
								}
								// loop the rules and queue some ancilliary calls
								_.each( task.rules, function( ruleValue, ruleName ) {
									validator[ruleName]( ruleValue );
								} );
							} else {
								throw new TypeError( self.options.messages.PARAMETER_TASKS_NOT_OBJECT );
							}
						}

						// execute the validation routines and push any errors onto the Praetorian stack
						validator.execute( function( err ) {
							if( err ){
								addError( elementPrefix + levelKey, err );
							}
						} );

					} else {
						// no validation found, whatevs...
					}

				}

			} );

		}

		try {

			// ensure json and schema are both objects
			if( !_.isObject( json ) ) {
				throw new TypeError( self.options.messages.PARAMETER_JSON_NOT_OBJECT );
			}
			if( !_.isObject( schema ) ) {
				throw new TypeError( self.options.messages.PARAMETER_SCHEMA_NOT_OBJECT );
			}
			if( !_.isFunction( callback ) ) {
				throw new TypeError( self.options.messages.PARAMETER_CALLBACK_NOT_FUNCTION );
			}

			parseJson( json, schema, '' );

			requiredJson( json, schema, '' );
			if( errors.length > 0 ) {
				// send the errors back
				callback( errors );
			} else {
				// send the decent json back
				callback( null, json );
			}
		} catch ( err ) {

			// somehow, return the err in the error callback
			if( callback ) {
				callback( err );
			} else {
				return err;
			}

		}

	};

	praetorian.prototype.requirements = function( schema, callback ) {

		try {

			var self = this;

			var addRequirement = function( field ) {
				var requirementRule = self.options.messages.RULE_NOT_GIVEN;
				// returns the field "requirement" details in a consistent schema
				if( ( field.validation ) && self.tasks && ( _.isFunction( self.tasks[field.validation] ) ) ) {
					var taskResult = self.tasks[field.validation].apply( null, field.arguments || null );
					requirementRule = taskResult.rule;
				} else if( ( field.validation ) && self.tasks && ( self.tasks[field.validation].rule ) ) {
					requirementRule = self.tasks[field.validation].rule;
				} else if( ( field.type ) && ( self.options.messages['RULE_MUST_BE_' + field.type.toUpperCase()] ) ) {
					requirementRule = self.options.messages['RULE_MUST_BE_' + field.type.toUpperCase()];
				}
				return {
					'rule': requirementRule,
					'description': ( field['description'] ) ? field['description'] : '',
					'required': ( field['required'] ) ? true : false
				};
			}

			var getRequirements = function( schema, requirements ) {
				var results = {};

				_.each( schema, function( schemaValue, schemaKey ) {
					if( schemaValue.type === primitiveTypes.OBJECT || schemaValue.type === primitiveTypes.ARRAY ) {
						// sub schema depending on the parent type, get the results for it
						var subSchemaResults = {};
						if( schemaValue.properties ) {
							subSchemaResults['properties'] = getRequirements( schemaValue.properties );
						} else {
							subSchemaResults['items'] = getRequirements( schemaValue.items );
						}
						// bind it with the requirements at this level and continue
						results[schemaKey] = _.extend( addRequirement( schemaValue ), subSchemaResults ) ;

					} else {
						// add some details to the results for the schema
						results[schemaKey] = addRequirement( schemaValue );
					}
				} );

				return results;

			}

			if( !_.isObject( schema ) ) {
				throw new TypeError( self.options.messages.PARAMETER_SCHEMA_NOT_OBJECT );
			}
			if( !_.isFunction( callback ) ) {
				throw new TypeError( self.options.messages.PARAMETER_CALLBACK_NOT_FUNCTION );
			}

			// send the results back a-la-node
			callback( null, getRequirements( schema ) );

		} catch ( err ) {
			// somehow, return the err in the error callback
			if( callback ) {
				callback( err );
			} else {
				return err;
			}
		}

	};

} )();