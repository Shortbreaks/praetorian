/**
* @name /.js
* @description Validates all inputs against a required structure and returns any errors that it finds
* @since Fri Oct 04 12:20:21 BST 2013
* @author Kevin Hodges <kevin.hodges@holidayextras.com>
*/

(function() {
	// get some stuff we need to support Praetorian
	var _ = require( 'underscore' ), moment = require( 'moment' );
	var praetorian = function() {};

	var primitiveTypes = {
		ARRAY: 'array',
		OBJECT: 'object',
		STRING: 'string',
		INTEGER: 'integer'
	}

	// create a shorthand then export the Praetorian object for NodeJS
	exports = module.exports = praetorian;

	praetorian.prototype.validate = function( json, schema, callback ) {

		/*
		*	An array of objects that define all the errors generated by the schema against
		*/
		var errors = [];

		var messagInvalidTypeMustBeArray = 'Invalid type, expected Array';
		var messagInvalidTypeMustBeObject = 'Invalid type, expected Object';

		var addError = function( element, message ) {
			// console.log( 'addError', element, message );
			errors.push( { 'element': element, 'message': message } );
		}

		// little closure to manage rule adherence
		var rules = function( data ) {
			// state for lifetime of the rules call (rules are chainable)
			var check = {
				data: data == null || ( isNaN( data ) && data.length == undefined ) ? '' : data,
				error: null
			}

			return {
				isString: function() {
					console.log( 'isString() on ', check.data );
					if( !_.isString( check.data ) ) {
						check.error = 'Not a string';
					}
					return this;
				},
				isInteger: function() {
					console.log( 'isInteger() on ', check.data );
					if( !_.isNumber( check.data ) ) {
						check.error = 'Not a number';
					}
					return this;
				},
				lengthBetween: function( min, max ) {
					console.log( 'lengthBetween() on ', check.data );
					if ( check.data.length < min ) {
						check.error = 'Value is too short';
					}
					if ( max !== undefined && check.data.length > max ) {
						check.error = 'Value is too long';
					}
					return this;
				},
				execute: function( callback ) {
					callback( check.error );
				}
			};
		}


		var parseJson = function( json, schema, schemaType, elementPrefix ) {

			// console.log('-=-=-=-=-=-=-');
			// console.log( 'received schemaType', schemaType );
			// console.log( 'received JSON', json );
			// console.log( 'received schema', schema );
			
			// for this level, loop over all the json and see if its required by the schema
			_.each( json, function( levelValue, levelKey ) {

				// console.log( 'levelKey', levelKey );
				// console.log( 'levelValue', levelValue );

				// is it a node in the schema?
				if( _.isUndefined( schema[levelKey] ) ) {
					// console.log( 'levelKey deleted "' + levelKey + '"' );
					// it's not, can it
					delete json[levelKey];
				} else {
					if( schema[levelKey].type === primitiveTypes.ARRAY ) {
						/* Array */
						// check its ACTUALLY an array
						if( _.isArray( json[levelKey] ) ) {
							// loop each element in the array and parse those as individual objects against their schema
							_.each( json[levelKey], function( arrayElement, loopCount ) {
								parseJson( arrayElement, schema[levelKey].properties, schema[levelKey].type, levelKey + '[' + loopCount + '].' );
							} );
						} else {
							// ERROR: this value should be an ARRAY but it's not (object of some other description?)
							addError( elementPrefix + levelKey, messagInvalidTypeMustBeArray );
						}
					} else if( schema[levelKey].type === primitiveTypes.OBJECT ) {
						/* Object */
						// must be an object (not null or undefined or anything silly)
						if( !_.isArray( json[levelKey] ) && !_.isNull( json[levelKey] ) && !_.isUndefined( json[levelKey] ) ) {
							parseJson( json[levelKey], schema[levelKey].properties, schema[levelKey].type, levelKey + '.' );
						} else {
							// ERROR: this value should be an OBJECT but its an array
							addError( elementPrefix + levelKey, messagInvalidTypeMustBeObject );
						}
					} else if( ( !_.isUndefined( schema[levelKey].validation ) ) && ( !_.isUndefined( schema[levelKey].validation.rules ) ) ) {

						// Handle anything else which has rules here (primitives? string, number...)
						_.each( schema[levelKey].validation.rules, function( rule, ruleKey ) {

							var validator = new rules( json[levelKey] );
							switch( ruleKey )  {

								case 'type':
									// basic type checking
									switch( rule ) {
										case 'string':
											validator.isString();
											break;

										case 'integer':
											validator.isInteger();
											break;
									}
									break;

								case 'length':
									validator.lengthBetween( rule.min, rule.max );
									break;

								default:
									// case not handled 
									break;

							}

							// execute the validation routines and push any errors onto the Praetorian stack
							validator.execute( function( err ) {
								if( err ){
									addError( elementPrefix + levelKey, err );
								}
							} );
						} );
						
					} else {
						// no validation found, whatevs...
						console.log( 'no validation', levelKey );
					}
					
				}

			} );

		}

		try {

			// ensure json and schema are both objects
			if( !_.isObject( json ) ) {
				throw new TypeError( 'parameter "json" is not [object]' );
			} 
			if( !_.isObject( schema ) ) {
				throw new TypeError( 'parameter "schema" is not [object]' );
			}
			if( !_.isFunction( callback ) ) {
				throw new TypeError( 'parameter "callback" is not [function]' );
			}

			// -1. Do we treat the whole thing as a stack? Or reusable "function"
			// 0. benchmark against Doorman for validating a data set against a structure
			// # 1. remove all junk data (recursive) keys that dont exist in the structure
			// 2. ensure items that are present (if REQUIRED) and are of the correct type
			// 3. check for ITEMS
			// 4. check for STRUCTURES
			// 5. what happens when we find an OBJECT? i.e. roomInfo on POST book
			// 6. deal with error handling (pass back up stack, modified data)
			// 7. individual validation routines
			// 8. config for Praetorian, build Doorman config in to somewhere but can be overridable :/
			// 9. isValidDate, isNumber etc, can we use Underscore (isFinite)?
			// 10. Identical objects are equal. `0 === -0`, but they aren't identical.
			// 11. better error messageing structure (consolidated)
			// 12. requirements() for outputting errors from a stack
			// 13. figure out what sort of return structures we will provide
			// 14. what is the difference between ARRAY and ITEMS
			// 15. list types, OBJECT ARRAY, STRUCTURE, ITEMS, CHECKSUM
			// 16. in Revolver, book roomInfo is ARRAY but is passed as [object]...
			
			// console.log( 'before', json );
			parseJson( json, schema, undefined, '' );
			// console.log( 'after', json );

			// check we have all required fields
			// _.each( structure, function( structure, structureKey ) {
			// 	// is this field "required"
			// 	if( ( structure['required'] ) && ( _.isUndefined( json[structureKey] ) ) ) {
			// 		// BOOO!, #fail
			// 		throw "get yo shit together";	
			// 	} else {
			// 		// "required" is false or undefined, ignore and continue
			// 	}
			// } );

			if( errors.length > 0 ) {
				// send the errors back
				callback( errors );
			} else {
				// send the decent json back
				callback( null, json );	
			}
		} catch ( err ) {

			// somehow, return the err in the error callback
			if( callback ) {
				callback( err );
			} else {
				return err;
			}

		}

	};

	praetorian.prototype.requirements = function( schema, callback ) {

		try {

			var results = [];
    	if( schema == null ) return results;

			function addRequirement( message, field ) {
				// returns the field "requirement" details in a consistent schema
				return {
					'example': message,
					'description': field['description'],
					'required': ( field['required'] ) ? true : false
				};
			}

			if( !_.isObject( schema ) ) {
				throw new TypeError( 'parameter "schema" is not [object]' );
			}
			if( !_.isFunction( callback ) ) {
				throw new TypeError( 'parameter "callback" is not [function]' );
			}

			_.each( schema, function( field, fieldKey ) {
				// add some details to the requirements
				results[fieldKey] = addRequirement( ( field.validation && field.validation.example ) ? field.validation.example : 'No example given', field );
			} );

			callback( null, results );

		} catch ( err ) {
			// somehow, return the err in the error callback
			if( callback ) {
				callback( err );
			} else {
				return err;
			}
		}

	};

})();